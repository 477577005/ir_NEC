基于stm32f103芯片的NEC红外协议接收器

1、NEC协议：
	数据帧组成：
		引导信号（9ms低电平+4.5ms高电平）+四字节数据（设备地址+设备地址取反+命令码+命令码取反）
	数据‘1’‘0’表示：
		数据‘1’（0.56ms低电平+0.56ms高电平）；数据‘0’（0.56ms低电平+1.65ms高电平）
2、数据解析方式：
	（1）while阻塞等待+输入捕获+软件延时
	（2）状态机+定时器+外部中断 （对比方式1，这个更适合于多任务场景，中断函数处理速度快）
3、环境
	编译软件：keil_MDK
	器件：stm32f103c8t6最小系统、HS0038B红外接收头

收获：
	1、学会了使用逻辑分析仪抓捕信号进行分析：
		使用过程中的遇到的问题，安装好驱动，点击开始捕获信号，立即就停止了，原因是我USB插在了USB拓展坞上，影响通信了。

	2、在寻找的示例代码中，发现了一个中断函数的执行规则：同一中断中，当芯片正在处理该中断函数时，如果当前没有执行完，
		即使再次触发中断，中断函数也不会从头执行，只会挂起一个中断请求，等待当前中断执行完毕才会去响应。

	3、在while中执行return，是退出函数，不仅仅是退出while循环。

	4、通过逻辑分析仪，发现数据校验时不对，针对第一个数据进行分析：原命令码0x45,串口打印的是十进制数69，正确，
		但是在value[2]=~value[3]时出现了错误，结果不相等，输出的命令码反码十进制186也与原命令码对应的上。
		问题就锁定在这个“value[2]=~value[3]”表达式,通过质询AI获得如下经验：
		（1）按位取反 (~)的隐式类型问题​
			unsigned char 的取反行为​：
			value[1] = 0xBA（十进制 186），~0xBA 的结果是 0x45（十进制 69）。
			但 ~ 操作默认会对操作数进行 ​整数提升​（提升为 int 类型），因此实际计算过程如下：
			~value[1] → ~(int)0xBA → 0xFFFFFF45（32位系统下）
			此时 value[0] == 0x45，而 ~value[1] == 0xFFFFFF45，两者不相等。
		​​(2) 修正方法：强制类型转换​
			需要将 ~ 的结果强制转回 unsigned char：
			if(value[0] == (unsigned char)~value[1])  // 显式转换
	5、红外信号的调制解调原理。
	6、定时器的参数配置，及各定时器中断的运用场景：
		prescaler 分频；couter period 计数周期
		计数时间=计数周期/频率
		中断类型						触发条件						典型应用场景
		Break Interrupt				外部断路信号输入						紧急停机、硬件保护
		Update Interrupt			计数器溢出/手动更新				周期性任务、定时器参数调整
		Trigger & Commutation			外部触发/电机换相事件				多定时器同步、电机控制
		Capture Compare Interrupt		捕获边沿或计数器匹配比较寄存器			脉冲测量、PWM生成
	7、学会使用串口打印数据进行分析，规划协议解析方式
	8、对GPIO的输入输出分析，使用逻辑分析仪提高处理问题效率
